<html><head><base href="https://holoprompt-3dsequencer-hz-db-labels.com/"><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=7.5, user-scalable=yes"><title>HOLOGRAM</title><link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet"><style>
        :root {
            --button-size: 9vw;
            --button-spacing: 1.5vw;
            --button-margin: 2vw;
            --timeline-height: 8vh;
            --color-bg: #000000;
            --color-primary: #FFFFFF;
            --color-scan: #FFFFFF;
            --button-hover-bg: rgba(255, 255, 255, 0.1);
            --scan-animation-duration: 2s;
            --scan-overlay-bg: rgba(0, 255, 0, 0.2);
            --button-stroke-width: 2;
        }
        body {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background-color: var(--color-bg);
            font-family: 'Roboto', sans-serif;
            color: var(--color-primary);
            touch-action: none;
        }
        #grid-container {
            position: absolute;
            top: calc(10vh + 15vh);
            left: 0;
            right: 0;
            bottom: calc(var(--button-size) + var(--button-margin) * 2 + var(--timeline-height) + 2vh);
            z-index: 2;
        }
        canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        .title-container {
            position: absolute;
            top: 12vh;
            left: var(--button-margin);
            right: var(--button-margin);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1vh 0;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            white-space: nowrap;
            background-color: transparent !important;
        }
        .title-container > #title {
            font-size: 9.88vw;
            background-color: transparent !important;
        }
        .title-container > .ai-label {
            font-size: calc(var(--button-size) / 4);
            font-weight: bold;
            background-color: var(--color-primary);
            color: black;
            padding: 0.5vw 1vw;
            border-radius: 10px;
            white-space: nowrap;
            margin-left: 0.5vw;
            align-self: center;
            margin-top: -9.88vw; /* Align lower edge of oval to top of HOLOGRAM header */
        }
        .button-container {
            position: absolute;
            bottom: var(--button-margin);
            left: var(--button-margin);
            right: var(--button-margin);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }
        button {
            width: var(--button-size);
            height: var(--button-size);
            background-color: transparent;
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s, filter 0.3s;
            color: var(--color-primary);
            margin: 0;
            padding: 0;
            position: relative;
            filter: brightness(0.7);
        }
        button.active {
            filter: brightness(1.5);
        }
        button:hover {
            background-color: var(--button-hover-bg);
        }
        button svg {
            fill: var(--color-primary);
            width: 60%;
            height: 60%;
            transition: fill 0.3s;
            vertical-align: middle;
        }
        button svg path {
            stroke-width: var(--button-stroke-width);
        }
        /* Mic Button Styles */
        #micButton {
            filter: brightness(0.7);
            transition: filter 0.3s;
        }
        #micButton.active {
            filter: brightness(1.5);
        }

        #timeline-container {
            position: absolute;
            bottom: calc(var(--button-size) + (var(--button-margin) * 2) + 1vh);
            left: var(--button-margin);
            width: calc(100% - (var(--button-margin) * 2));
            height: var(--timeline-height);
            background-color: #222;
            z-index: 15;
        }
        #playhead {
            position: absolute;
            top: 0;
            left: 0;
            width: 2px;
            height: 100%;
            background-color: #f00;
            pointer-events: none;
        }
        #camera-view {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: none;
            z-index: 1;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
        }
        .modal-content {
            background-color: rgba(26, 26, 26, 0.9);
            margin: 15vh auto;
            padding: 20px;
            border-radius: 8px;
            max-width: 80%;
            max-height: 70vh;
            overflow: auto;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .xr-arrow {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            width: calc(var(--button-size) / 4);
            height: calc(var(--button-size) / 4);
            fill: #FFFFFF;
            display: none;
        }
        .xr-button-active .xr-arrow {
            display: block;
        }
        #gestureRecordButton, #toggleCameraButton, #copy-notification, #scanOverlay, #eyeButton {
            display: block;
        }
        #gestureModal, #copy-notification, #scanOverlay {
            display: none !important;
        }
        #scanOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--scan-overlay-bg);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: scanAnimation var(--scan-animation-duration) forwards;
        }
        @keyframes scanAnimation {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }
        .scan-active {
            animation: scanPulse var(--scan-animation-duration) infinite;
        }
        @keyframes scanPulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
            100% { transform: scale(1); opacity: 1; }
        }
        /* Additional CSS for XR arrows */
        #xrLabel {
        }
        #xrArrow1,
        #xrArrow2 {
            position: absolute;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        #xrArrow1 {
            transform: translate(-50%, -50%) rotate(0deg); /* Rotate arrow 1 */
        }
        #xrArrow2 {
            transform: translate(-50%, -50%) rotate(180deg); /* Rotate arrow 2 */
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" defer></script>
    <script src="https://threejs.org/examples/js/loaders/FontLoader.js" defer></script>
    <script src="https://threejs.org/examples/js/geometries/TextGeometry.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js" defer></script>
    <script src="handpose.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.9.0/dist/tf.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose@0.0.7/dist/handpose.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/renderers/CSS2DRenderer.js" defer></script>
    <script async src="https://telegram.org/js/telegram-web-app.js"></script>
</head><body>
    <video id="camera-view" autoplay playsinline></video>
    <div class="title-container">
        <div id="title">HOLOGRAM</div>
        <div class="ai-label">AI CRAFT</div>
    </div>
    <div id="grid-container"></div>
    <div id="copy-notification">Code copied to clipboard!</div>
    <div id="scanOverlay"></div>
    <div class="button-container">
        <button id="fileButton" aria-label="Upload Audio File">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="var(--color-primary)" width="60%" height="60%">
                <path d="M12 5v14m-7-7h14" stroke="currentColor" stroke-width="2" />
            </svg>
        </button>
        <button id="playPauseButton" aria-label="Play/Pause" disabled>
            <svg id="playIcon" class="icon-visible" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="var(--color-primary)" width="60%" height="60%">
                <path d="M8 5v14l11-7z" />
            </svg>
            <svg id="pauseIcon" class="icon-hidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="var(--color-primary)" width="60%" height="60%">
                <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z" />
            </svg>
        </button>
        <button id="micButton" aria-label="Microphone">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="var(--color-primary)" width="60%" height="60%">
                <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z" />
                <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z" />
            </svg>
        </button>
        <button id="fullscreenButton" aria-label="Fullscreen">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="var(--color-primary)" width="60%" height="60%">
                <path d="M3 3h6v2H5v4H3V3z" />
                <path d="M3 21h6v-2H5v-4H3v6z" />
                <path d="M21 3h-6v2h4v4h2V3z" />
                <path d="M21 21h-6v-2h4v-4h2v6z" />
            </svg>
        </button>
        <button id="xrButton" aria-label="Extended Reality">
            <svg id="xrLabel" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="var(--color-primary)" width="60%" height="60%">
                <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-size="18" fill="var(--color-primary)" dy=".3em">XR</text>
            </svg>
            <svg id="xrArrow1" class="xr-arrow" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#FFFFFF" stroke-width="2" style="display:none;">
                <path d="M4 12a8 8 0 018-8"></path>
                <path d="M12 4v8h-4"></path>
            </svg>
            <svg id="xrArrow2" class="xr-arrow" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#FFFFFF" stroke-width="2" style="display:none;">
                <path d="M20 12a8 8 0 01-8 8"></path>
                <path d="M12 20v-8h4"></path>
            </svg>
        </button>
        <button id="gestureRecordButton" aria-label="Magnifier">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="var(--color-primary)" width="60%" height="60%">
                <circle cx="10" cy="10" r="7" stroke="currentColor" stroke-width="2" fill="none" />
                <line x1="15" y1="15" x2="20" y2="20" stroke="currentColor" stroke-width="2" />
            </svg>
        </button>
        <button id="scanButton" aria-label="Scan">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="60%" height="60%">
                <path d="M6,6 h3 M15,6 h3 M6,18 h3 M15,18 h3 M6,6 v3 M6,15 v3 M18,6 v3 M18,15 v3" 
                      stroke="var(--color-scan)" 
                      stroke-width="2"
                      fill="none"/>
                <rect x="8" y="8" width="8" height="8" rx="1" ry="1" fill="var(--color-scan)"/>
            </svg>
        </button>
        <button id="eyeButton" aria-label="Toggle Grids">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="var(--color-primary)" width="60%" height="60%">
                <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
            </svg>
        </button>
    </div>
    <button id="toggleCameraButton" aria-label="Switch Camera" style="display: none;">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="var(--color-primary)">
            <path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6h-2c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z" />
        </svg>
    </button>
    <input type="file" id="fileInput" accept="audio/*" style="display: none;">
    <div id="timeline-container">
        <canvas id="timeline-canvas"></canvas>
        <div id="playhead"></div>
    </div>
    <div id="gestureModal" class="gesture-modal">
        <div class="gesture-modal-content">
            <span class="close-button" id="closeGestureModal">&times;</span>
            <h2>Gesture Recording</h2>
            <p id="gestureStatus">Press "Start Recording" to begin.</p>
            <button id="startRecordingButton">Start Recording</button>
            <button id="stopRecordingButton" disabled>Stop Recording</button>
            <div id="gestureVisualization" style="margin-top:20px;">
                <canvas id="gestureCanvas" width="500" height="300" style="background-color:#333;"></canvas>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const projectId = 'your-current-project-id';
            const visualizationParams = {
                animationSpeed: 0.1,
                minOpacity: 1.0,
                maxOpacity: 1.0,
                minColumnDepth: 1,
                maxColumnDepth: 260,
                maxDB: 130
            };
            const GRID_WIDTH = 130;
            const GRID_HEIGHT = 260;
            const GRID_DEPTH = 130;
            const CELL_SIZE = 1;
            const SPHERE_RADIUS = 5; 
            const INITIAL_SCALE = 1.2; 
            const ROTATION_LIMIT = THREE.MathUtils.degToRad(70);
            const SCALE_FACTOR = 0.005;

            const semitones = Array.from({ length: 130 }, (_, i) => ({
                deg: i,
                f: 27.5 * Math.pow(2, i / 12)
            }));

            const scene = new THREE.Scene();
            const camera = new THREE.OrthographicCamera(
                -window.innerWidth / 2,
                window.innerWidth / 2,
                window.innerHeight / 2,
                -window.innerHeight / 2,
                -10000,
                10000
            );
            camera.position.set(0, 600, 1600);
            camera.lookAt(0, 0, 0);
            const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance", alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('grid-container').appendChild(renderer.domElement);
            const labelMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, depthTest: false });
            let isXRMode = false;
            let videoStream = null;
            let videoElement = null;
            let startOffset = 0;
            let startTimestamp = 0;
            let audioContext = null;
            let audioBufferSource = null;
            let isPlaying = false;
            let pauseTime = 0;
            let referenceAmplitude = 1; 
            let analyserLeft, analyserRight;
            const columns = [];
            const timelineContainer = document.getElementById('timeline-container');
            const timelineCanvas = document.getElementById('timeline-canvas');
            const playhead = document.getElementById('playhead');
            const cameraView = document.getElementById('camera-view');
            const ctx = timelineCanvas.getContext('2d');

            let timelineWidth = timelineContainer.clientWidth;
            let timelineHeight = timelineContainer.clientHeight;
            timelineCanvas.width = timelineWidth;
            timelineCanvas.height = timelineHeight;
            let hologramWidth = GRID_WIDTH * 2 * INITIAL_SCALE;
            let scaleFactor = timelineWidth / hologramWidth * 0.9;
            const mainSequencerGroup = new THREE.Group();
            mainSequencerGroup.scale.set(INITIAL_SCALE * scaleFactor, INITIAL_SCALE * scaleFactor, INITIAL_SCALE * scaleFactor);
            scene.add(mainSequencerGroup);
            renderer.autoClear = false;

            const defaultMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                opacity: 0.001,
                transparent: true,
                depthWrite: false,
                depthTest: false
            });

            function createSphere(color, radius) {
                const geometry = new THREE.SphereGeometry(radius * 0.5, 32, 32);
                const material = new THREE.MeshBasicMaterial({ color, depthTest: false });
                return new THREE.Mesh(geometry, material);
            }

            function createLine(start, end, color, opacity) {
                const material = new THREE.LineBasicMaterial({ color, opacity, transparent: true, depthTest: false });
                const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
                return new THREE.Line(geometry, material);
            }

            function createGrid(gridWidth, gridHeight, gridDepth, cellSize, color) {
                const geometry = new THREE.BufferGeometry();
                const positions = [];
                for (let y = 0; y <= gridHeight; y += 1) {
                    for (let z = 0; z <= gridDepth; z += 1) {
                        positions.push(0, y * cellSize, z * cellSize, gridWidth * cellSize, y * cellSize, z * cellSize);
                    }
                }
                for (let x = 0; x <= gridWidth; x += 1) {
                    for (let z = 0; z <= gridDepth; z += 1) {
                        positions.push(x * cellSize, 0, z * cellSize, x * cellSize, gridHeight * cellSize, z * cellSize);
                    }
                }
                for (let z = 0; z <= gridWidth; z += 1) {
                    for (let y = 0; y <= gridHeight; y += 1) {
                        positions.push(z * cellSize, y * cellSize, 0, z * cellSize, y * cellSize, gridDepth * cellSize);
                    }
                }
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                const material = new THREE.LineBasicMaterial({
                    color,
                    opacity: 0.003,
                    transparent: true,
                    depthWrite: false,
                    depthTest: false
                });
                return new THREE.LineSegments(geometry, material);
            }

            function createAxis(length, sphereRadius, xColor, yColor, zColor, isLeftGrid) {
                const axisGroup = new THREE.Group();
                const xAxisOffset = isLeftGrid ? GRID_WIDTH : 0;

                const xAxisGroup = new THREE.Group();
                axisGroup.add(xAxisGroup);
                const xAxis = createSphere(xColor, sphereRadius);
                xAxis.position.set(length, 0, 0);
                if (isLeftGrid) xAxis.position.x *= -1;
                xAxisGroup.add(xAxis);
                const xAxisLine = createLine(new THREE.Vector3(0, 0, 0), new THREE.Vector3(length, 0, 0), xColor, visualizationParams.maxOpacity);
                xAxisGroup.add(xAxisLine);
                xAxisGroup.position.set(xAxisOffset, 0, 0);

                const yAxisGroup = new THREE.Group();
                axisGroup.add(yAxisGroup);
                const yAxis = createSphere(yColor, sphereRadius);
                yAxis.position.set(0, GRID_HEIGHT, 0);
                yAxisGroup.add(yAxis);
                const yAxisLine = createLine(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, GRID_HEIGHT, 0), yColor, visualizationParams.maxOpacity);
                yAxisGroup.add(yAxisLine);
                yAxisGroup.position.set(xAxisOffset, 0, 0);

                const zAxisGroup = new THREE.Group();
                axisGroup.add(zAxisGroup);
                const zAxis = createSphere(zColor, sphereRadius);
                zAxis.position.set(0, 0, length);
                zAxisGroup.add(zAxis);
                const zAxisLine = createLine(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, length), zColor, visualizationParams.maxOpacity);
                zAxisGroup.add(zAxisLine);
                zAxisGroup.position.set(xAxisOffset, 0, 0);

                return axisGroup;
            }

            function createSequencerGrid(width, height, depth, cellSize, color, position, isLeftGrid) {
                const grid = createGrid(width, height, depth, cellSize, color);
                const axis = createAxis(width, SPHERE_RADIUS,
                    isLeftGrid ? 0x9400d3 : 0xFF0000,
                    0x00FF00,
                    0xFFFFFF,
                    isLeftGrid
                );
                const sequencerGroup = new THREE.Group();
                sequencerGroup.add(grid);
                sequencerGroup.add(axis);
                sequencerGroup.position.copy(position);
                return sequencerGroup;
            }

            const leftSequencerGroup = createSequencerGrid(
                GRID_WIDTH,
                GRID_HEIGHT,
                GRID_DEPTH,
                CELL_SIZE,
                0x9400d3,
                new THREE.Vector3(-GRID_WIDTH / 2 - 65, 0, -GRID_DEPTH / 2),
                true
            );
            const rightSequencerGroup = createSequencerGrid(
                GRID_WIDTH,
                GRID_HEIGHT,
                GRID_DEPTH,
                CELL_SIZE,
                0xFF0000,
                new THREE.Vector3(GRID_WIDTH / 2 - 65, 0, -GRID_DEPTH / 2),
                false
            );
            mainSequencerGroup.add(leftSequencerGroup, rightSequencerGroup);

            function initializeColumns() {
                if (columns.length === 0) {
                    semitones.forEach((semitone, i) => {
                        const initialDB = 0;
                        const maxOffset = degreesToCells(semitone.deg);
                        const offsetLeft = i;
                        const columnLeft = createColumn(offsetLeft, i + 1, initialDB, true);
                        const columnRight = createColumn(offsetLeft, i + 1, initialDB, false);
                        columns.push({
                            left: columnLeft,
                            right: columnRight,
                            offsetX: 0,
                            direction: 1,
                            maxOffset: maxOffset,
                            speed: Math.random() * visualizationParams.animationSpeed + 0.1,
                            dB: initialDB,
                            dBDirection: 1
                        });
                    });
                }
                columns.forEach(column => {
                    if (!column.left.parent) leftSequencerGroup.add(column.left);
                    if (!column.right.parent) rightSequencerGroup.add(column.right);
                });
            }

            function getSemitoneLevels(analyser) {
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteFrequencyData(dataArray);
                const sampleRate = audioContext.sampleRate;
                const binSize = sampleRate / (2 * bufferLength);
                return semitones.map(semitone => {
                    const binIndex = Math.round(semitone.f / binSize);
                    if (binIndex >= bufferLength) return -100;
                    const amplitude = dataArray[binIndex];
                    if (amplitude === 0) return -100;
                    const dB = 20 * Math.log10(amplitude / 255) * 1.5;
                    return THREE.MathUtils.clamp(dB, -100, 30);
                });
            }

            function updateSequencerColumns(amplitudes, channel) {
                columns.forEach((column, i) => {
                    const dB = amplitudes[i];
                    if (isNaN(dB)) return;
                    const normalizedDB = THREE.MathUtils.clamp(
                        (dB + 100) / (visualizationParams.maxDB + 100), 
                        0, 
                        1
                    );
                    const channelGroup = channel === 'left' ? column.left : column.right;
                    const { opacity, color } = calculateOpacityAndColor(i);
                    channelGroup.children.forEach(mesh => {
                        mesh.material.opacity = 1.0;
                        mesh.material.transparent = false;
                        mesh.material.color = color;
                        const depth = normalizedDB * visualizationParams.maxColumnDepth;
                        mesh.scale.z = depth;
                        mesh.position.z = depth / 2;
                    });
                });
            }

            function setupAudioProcessing(source) {
                const splitter = audioContext.createChannelSplitter(2);
                analyserLeft = audioContext.createAnalyser();
                analyserRight = audioContext.createAnalyser();
                analyserLeft.fftSize = 4096;
                analyserRight.fftSize = 4096;
                analyserLeft.smoothingTimeConstant = 0.3;
                analyserRight.smoothingTimeConstant = 0.3;
                source.connect(splitter);
                splitter.connect(analyserLeft, 0);
                splitter.connect(analyserRight, 1);

                function processAudio() {
                    if (isPlaying) {
                        const semitoneAmplitudesLeft = getSemitoneLevels(analyserLeft);
                        const semitoneAmplitudesRight = getSemitoneLevels(analyserRight);
                        updateSequencerColumns(semitoneAmplitudesLeft, 'left');
                        updateSequencerColumns(semitoneAmplitudesRight, 'right');
                        requestAnimationFrame(processAudio);
                    }
                }
                processAudio();
            }

            initializeColumns();

            setInterval(() => {
                if (isPlaying) {
                    const semiLevelsLeft = getSemitoneLevels(analyserLeft);
                    const semiLevelsRight = getSemitoneLevels(analyserRight);
                    updateSequencerColumns(semiLevelsLeft, 'left');
                    updateSequencerColumns(semiLevelsRight, 'right');
                }
            }, 50);

            let selectedX = 0;
            let selectedY = 0;
            let selectedZ = 0;
            let currentColumn = null;
            const loader = new THREE.FontLoader();

            function calculateOpacityAndColor(index) {
                const hue = (index / (semitones.length - 1)) * 360;
                const saturation = 100;
                const lightness = 50;
                const color = new THREE.Color(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
                const opacity = 1.0;
                return { opacity, color };
            }

            function degreesToCells(degrees) {
                const maxWidth = 130;
                const minWidth = 1;
                const totalSemitones = semitones.length;
                const width = maxWidth - ((degrees / (totalSemitones - 1)) * (maxWidth - minWidth));
                return Math.max(minWidth, Math.round(width));
            }

            function createColumn(x, y, dB, isLeftGrid) {
                const { opacity, color: lineColor } = calculateOpacityAndColor(y - 1);
                const semitone = semitones[y - 1];
                const width = degreesToCells(semitone.deg);
                const startX = isLeftGrid ? GRID_WIDTH - width : 0;

                const columnGroup = new THREE.Group();
                columnGroup.dB = dB;
                columnGroup.position.x = startX;
                columnGroup.position.y -= 1; // Move down by one cell along Y-axis

                const geometry = new THREE.BoxGeometry(width, 2, 1);
                const material = new THREE.MeshBasicMaterial({ color: lineColor, opacity: 1.0, transparent: false, depthTest: false });
                const columnMesh = new THREE.Mesh(geometry, material);
                columnGroup.add(columnMesh);
                columnMesh.position.set(width / 2, y * 2, 0); // Adjusted Y position

                return columnGroup;
            }

            const fileButton = document.getElementById('fileButton');
            const fileInput = document.getElementById('fileInput');
            const playPauseButton = document.getElementById('playPauseButton');
            let fileSource = null;

            fileButton.addEventListener('click', () => {
                fileInput.click();
            });

            fileInput.addEventListener('change', () => {
                const file = fileInput.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        if (audioBufferSource) {
                            audioBufferSource.stop();
                            audioBufferSource.disconnect();
                            audioBufferSource = null;
                        }
                        if (audioContext) {
                            audioContext.close();
                            audioContext = null;
                        }

                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        audioContext.decodeAudioData(e.target.result)
                            .then(buffer => {
                                fileSource = buffer;
                                playPauseButton.disabled = false;
                                startOffset = 0;
                                fileButton.classList.add('active');
                            })
                            .catch(err => {
                                console.error('Error decoding audio data:', err);
                            });
                    };
                    reader.readAsArrayBuffer(file);
                }
            });

            const micButton = document.getElementById('micButton');
            let isRecording = false;
            let microphoneStream;

            micButton.addEventListener('click', () => {
                if (!isRecording) {
                    micButton.classList.add('active');
                    navigator.mediaDevices.getUserMedia({ audio: true })
                        .then(stream => {
                            if (!audioContext) {
                                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            }
                            microphoneStream = stream;
                            const source = audioContext.createMediaStreamSource(stream);
                            setupAudioProcessing(source); 
                            isRecording = true;
                            isPlaying = true; // Start animation when recording
                        })
                        .catch(err => {
                            console.error("Error accessing microphone:", err);
                            micButton.classList.remove('active');
                            isRecording = false;
                            isPlaying = false;
                        });
                } else {
                    micButton.classList.remove('active');
                    if (microphoneStream) {
                        microphoneStream.getTracks().forEach(track => track.stop());
                        microphoneStream = null;
                    }
                    if (audioContext && audioBufferSource) {
                        audioBufferSource.disconnect();
                        analyserLeft.disconnect();
                        analyserRight.disconnect();
                    }
                    isRecording = false;
                    isPlaying = false; // Stop animation when recording stops
                }
            });

            const playPauseButtonOriginalHTML = playPauseButton.innerHTML;

            playPauseButton.addEventListener('click', () => {
                if (!fileSource) return;

                const playIcon = document.getElementById('playIcon');
                const pauseIcon = document.getElementById('pauseIcon');

                if (!isPlaying) {
                    if (!audioContext) {
                        audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    }

                    audioBufferSource = audioContext.createBufferSource();
                    audioBufferSource.buffer = fileSource;

                    setupAudioProcessing(audioBufferSource);
                    
                    audioBufferSource.connect(audioContext.destination);
                    audioBufferSource.start(0, startOffset);
                    startTimestamp = audioContext.currentTime - startOffset;
                    isPlaying = true;
                    playPauseButton.classList.add('active');

                    playIcon.classList.add('icon-hidden');
                    playIcon.classList.remove('icon-visible');
                    pauseIcon.classList.add('icon-visible');
                    pauseIcon.classList.remove('icon-hidden');

                    audioBufferSource.onended = () => {
                        isPlaying = false;
                        startOffset = 0;
                        playPauseButton.classList.remove('active');
                        playIcon.classList.add('icon-visible');
                        playIcon.classList.remove('icon-hidden');
                        pauseIcon.classList.add('icon-hidden');
                        pauseIcon.classList.remove('icon-visible');
                    };
                } else {
                    if (audioBufferSource) {
                        audioBufferSource.stop();
                        audioBufferSource.disconnect();
                        audioBufferSource = null;
                        startOffset = audioContext.currentTime - startTimestamp;
                        isPlaying = false;
                        playPauseButton.classList.remove('active');

                        playIcon.classList.add('icon-visible');
                        playIcon.classList.remove('icon-hidden');
                        pauseIcon.classList.add('icon-hidden');
                        pauseIcon.classList.remove('icon-visible');
                    }
                }
            });

            let recordedGestures = [];
            const gestureModal = document.getElementById('gestureModal');
            const gestureRecordButton = document.getElementById('gestureRecordButton');
            const closeGestureModal = document.getElementById('closeGestureModal');
            const startRecordingButton = document.getElementById('startRecordingButton');
            const stopRecordingButton = document.getElementById('stopRecordingButton');
            const gestureStatus = document.getElementById('gestureStatus');
            const gestureCanvas = document.getElementById('gestureCanvas');
            const gestureCtx = gestureCanvas.getContext('2d');
            let isGestureRecording = false;
            let gestureData = [];
            let gestureStartTime = 0;

            gestureRecordButton.addEventListener('click', () => {
                gestureModal.style.display = 'block';
                gestureRecordButton.classList.add('active');
            });

            closeGestureModal.addEventListener('click', () => {
                gestureModal.style.display = 'none';
                resetGestureRecording();
                gestureRecordButton.classList.remove('active');
            });

            startRecordingButton.addEventListener('click', () => {
                if (!isGestureRecording) {
                    isGestureRecording = true;
                    gestureData = [];
                    gestureStartTime = Date.now();
                    gestureStatus.textContent = 'Recording gesture...';
                    startRecordingButton.disabled = true;
                    stopRecordingButton.disabled = false;
                    gestureCanvas.width = gestureCanvas.clientWidth;
                    gestureCanvas.height = gestureCanvas.clientHeight;
                    gestureCtx.clearRect(0, 0, gestureCanvas.width, gestureCanvas.height);
                    gestureRecordButton.classList.add('active');
                }
            });

            stopRecordingButton.addEventListener('click', () => {
                if (isGestureRecording) {
                    isGestureRecording = false;
                    gestureStatus.textContent = 'Gesture recorded.';
                    startRecordingButton.disabled = false;
                    stopRecordingButton.disabled = true;
                    visualizeGesture();
                    gestureRecordButton.classList.remove('active');
                }
            });

            function resetGestureRecording() {
                isGestureRecording = false;
                gestureData = [];
                gestureStatus.textContent = 'Press "Start Recording" to begin.';
                startRecordingButton.disabled = false;
                stopRecordingButton.disabled = true;
                gestureCtx.clearRect(0, 0, gestureCanvas.width, gestureCanvas.height);
            }

            async function setupHandposeForGesture() {
                try {
                    const handposeModel = await handpose.load();
                    setInterval(async () => {
                        if (currentStream && isGestureRecording) {
                            const predictions = await handposeModel.estimateHands(cameraView);
                            if (predictions.length > 0) {
                                const landmarks = predictions[0].landmarks;
                                const timestamp = Date.now() - gestureStartTime;
                                gestureData.push({ landmarks, timestamp });
                                drawGestureFrame(landmarks);
                            }
                        }
                    }, 100);
                } catch (err) {
                    console.error('Error setting up Handpose for gesture recording:', err);
                }
            }

            function drawGestureFrame(landmarks) {
                gestureCtx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                gestureCtx.beginPath();
                landmarks.forEach((point, index) => {
                    const x = (point[0] / cameraView.videoWidth) * gestureCanvas.width;
                    const y = (point[1] / cameraView.videoHeight) * gestureCanvas.height;
                    if (index === 0) {
                        gestureCtx.moveTo(x, y);
                    } else {
                        gestureCtx.lineTo(x, y);
                    }
                });
                gestureCtx.strokeStyle = '#00FF00';
                gestureCtx.lineWidth = 2;
                gestureCtx.stroke();
            }

            function visualizeGesture() {
                gestureCtx.clearRect(0, 0, gestureCanvas.width, gestureCanvas.height);
                gestureCtx.strokeStyle = '#00FF00';
                gestureCtx.lineWidth = 2;
                gestureCtx.beginPath();
                gestureData.forEach(({ landmarks }, index) => {
                    const fingertip = landmarks[8];
                    const x = (fingertip[0] / cameraView.videoWidth) * gestureCanvas.width;
                    const y = (fingertip[1] / cameraView.videoHeight) * gestureCanvas.height;
                    if (index === 0) {
                        gestureCtx.moveTo(x, y);
                    } else {
                        gestureCtx.lineTo(x, y);
                    }
                });
                gestureCtx.stroke();
            }

            setupHandposeForGesture();

            const hammer = new Hammer(renderer.domElement);
            hammer.get('pan').set({ direction: Hammer.DIRECTION_ALL });

            let currentRotationX = 0;
            let currentRotationY = 0;

            hammer.on('pan', (ev) => {
                const deltaX = ev.deltaX * 0.01;
                const deltaY = ev.deltaY * 0.01;

                let newRotationY = currentRotationY + deltaX;
                let newRotationX = currentRotationX + deltaY;

                newRotationX = THREE.MathUtils.clamp(newRotationX, -ROTATION_LIMIT, ROTATION_LIMIT);
                newRotationY = THREE.MathUtils.clamp(newRotationY, -ROTATION_LIMIT, ROTATION_LIMIT);

                mainSequencerGroup.rotation.y = newRotationY;
                mainSequencerGroup.rotation.x = newRotationX;
            });

            hammer.on('panend', () => {
                currentRotationX = mainSequencerGroup.rotation.x;
                currentRotationY = mainSequencerGroup.rotation.y;
            });

            mainSequencerGroup.position.set(0, 0, 0);

            function updatePlayhead() {
                if (!isPlaying || !audioBufferSource || !audioBufferSource.buffer) return;
                const currentTime = audioContext.currentTime - startTimestamp;
                const duration = audioBufferSource.buffer.duration;
                if (currentTime >= duration) {
                    playhead.style.left = `${timelineWidth}px`;
                    return;
                }
                const progress = duration ? (currentTime / duration) : 0;
                playhead.style.left = `${progress * timelineWidth}px`;
            }

            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
                updatePlayhead();
            }
            animate();

            const fullscreenButton = document.getElementById('fullscreenButton');
            fullscreenButton.addEventListener('click', () => {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen();
                } else {
                    document.exitFullscreen();
                }
                fullscreenButton.classList.toggle('active');
            });

            const xrButton = document.getElementById('xrButton');
            const toggleCameraButton = document.getElementById('toggleCameraButton');
            let currentStream = null;
            let useFrontCamera = true;
            let xrState = 0; // 0: Off, 1: Back Camera, 2: Front Camera

            xrButton.addEventListener('click', async () => {
                xrState = (xrState + 1) % 3;
                switch(xrState) {
                    case 0:
                        // Off
                        document.getElementById('xrLabel').style.display = 'block';
                        document.getElementById('xrArrow1').style.display = 'none';
                        document.getElementById('xrArrow2').style.display = 'none';
                        if (currentStream) {
                            stopStream();
                        }
                        xrButton.classList.remove('active');
                        break;
                    case 1:
                        // Back Camera
                        document.getElementById('xrLabel').style.display = 'none';
                        document.getElementById('xrArrow1').style.display = 'block';
                        document.getElementById('xrArrow2').style.display = 'block';
                        try {
                            const constraints = {
                                video: { facingMode: "environment" },
                                audio: false
                            };
                            currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                            cameraView.srcObject = currentStream;
                            cameraView.style.display = 'block';
                            toggleCameraButton.style.display = 'flex';
                            await setupHandpose(currentStream);
                            document.body.style.backgroundColor = 'transparent';
                            xrButton.classList.add('active');
                        } catch (err) {
                            console.error('Error accessing back camera:', err);
                            xrButton.classList.remove('active');
                        }
                        break;
                    case 2:
                        // Front Camera
                        document.getElementById('xrLabel').style.display = 'none';
                        document.getElementById('xrArrow1').style.display = 'block';
                        document.getElementById('xrArrow2').style.display = 'block';
                        try {
                            if (currentStream) {
                                stopStream();
                            }
                            const constraints = {
                                video: { facingMode: "user" },
                                audio: false
                            };
                            currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                            cameraView.srcObject = currentStream;
                            cameraView.style.display = 'block';
                            toggleCameraButton.style.display = 'flex';
                            await setupHandpose(currentStream);
                            document.body.style.backgroundColor = 'transparent';
                            xrButton.classList.add('active');
                        } catch (err) {
                            console.error('Error accessing front camera:', err);
                            xrButton.classList.remove('active');
                        }
                        break;
                }
            });

            toggleCameraButton.addEventListener('click', async () => {
                if (currentStream) {
                    useFrontCamera = !useFrontCamera;
                    stopStream();
                    try {
                        const constraints = {
                            video: { facingMode: useFrontCamera ? "user" : "environment" },
                            audio: false
                        };
                        currentStream = await navigator.mediaDevices.getUserMedia(constraints);
                        cameraView.srcObject = currentStream;
                    } catch (err) {
                        console.error('Error switching camera:', err);
                    }
                }
            });

            function stopStream() {
                if (currentStream) {
                    currentStream.getTracks().forEach(track => track.stop());
                    currentStream = null;
                }
                cameraView.srcObject = null;
                cameraView.style.display = 'none';
                toggleCameraButton.style.display = 'none';
                document.body.style.backgroundColor = 'var(--color-bg)';
                xrButton.classList.remove('active');
            }

            function setupHandpose(videoStream) {
                return handpose.load().then(handposeModel => {
                    setInterval(async () => {
                        if (videoStream && isGestureRecording && isPlaying) {
                            const predictions = await handposeModel.estimateHands(cameraView);
                            if (predictions.length > 0) {
                                const fingertips = predictions[0].landmarks.slice(8, 20, 4);
                                const frameData = {
                                    timestamp: Date.now(),
                                    fingertips: fingertips.map(point => ({ x: point[0], y: point[1], z: point[2] }))
                                };
                                recordedGestures.push(frameData);
                                drawTimeline();
                            }
                        }
                    }, 50);
                }).catch(err => {
                    console.error('Error setting up handpose:', err);
                });
            }

            function drawTimeline() {
                ctx.clearRect(0, 0, timelineWidth, timelineHeight);
                if (recordedGestures.length > 0) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    recordedGestures.forEach((frame, i) => {
                        const x = (i / recordedGestures.length) * timelineWidth;
                        const y = frame.fingertips ? (frame.fingertips[0].y / cameraView.videoHeight) * timelineHeight : timelineHeight / 2;
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    });
                    ctx.stroke();
                }
            }

            if (window.Telegram) {
                Telegram.WebApp.ready();
                Telegram.WebApp.onEvent('data', (data) => {
                    if (data && data.text) {
                        const aiLabel = document.querySelector('.ai-label');
                        const parts = data.text.split(' ', 2);
                        const firstPart = parts[0] || '';
                        const secondPart = parts[1] || '';
                        aiLabel.innerHTML = `<span>${firstPart}</span><span>${secondPart}</span>`;
                    }
                });
            } else {
                console.log('Telegram WebApp not available');
            }

            window.addEventListener('resize', () => {
                const width = window.innerWidth;
                const height = window.innerHeight;

                camera.left = -width / 2;
                camera.right = width / 2;
                camera.top = height / 2;
                camera.bottom = -height / 2;
                camera.updateProjectionMatrix();

                renderer.setSize(width, height);
                timelineWidth = timelineContainer.clientWidth;
                timelineHeight = timelineContainer.clientHeight;
                timelineCanvas.width = timelineWidth;
                timelineCanvas.height = timelineHeight;
                hologramWidth = GRID_WIDTH * 2 * INITIAL_SCALE;
                scaleFactor = timelineWidth / hologramWidth * 0.9;
                mainSequencerGroup.scale.set(INITIAL_SCALE * scaleFactor, INITIAL_SCALE * scaleFactor, INITIAL_SCALE * scaleFactor);
            });

            const scanButton = document.getElementById('scanButton');
            const scanOverlay = document.getElementById('scanOverlay');

            scanButton.addEventListener('click', () => {
                scanOverlay.style.display = 'flex';
                scanButton.classList.add('scan-active');

                setTimeout(() => {
                    scanOverlay.style.display = 'none';
                    scanButton.classList.remove('scan-active');
                    activateDecodingFunctions();
                }, 2000);
            });

            function activateDecodingFunctions() {
                console.log('Decoding gestures, audio, text, video, and other data from the hologram.');

                if (isGestureRecording) {
                    console.log('Decoding gestures...');
                }

                if (isPlaying) {
                    console.log('Decoding audio...');
                }

                console.log('Decoding text...');
                console.log('Decoding video...');
            }

            // Eye Button Functionality
            const eyeButton = document.getElementById('eyeButton');
            eyeButton.addEventListener('click', () => {
                mainSequencerGroup.visible = !mainSequencerGroup.visible;
                eyeButton.classList.toggle('active');
            });
        });
    </script>
</body></html>